/*
  lexical_analizer.cpp
  Лексический анализатор.
  Модуль отвечает за выделение лексем из входного текста.
*/

#include "stdafx.h"
#include "lexical_analizer.h"

Parser::Parser(std::istream& in) // Конструктор
    : in(in), line_number(1) {
    last.type = LT_Unknown; // Тип последней лексеммы неизвестен
    in >> std::noskipws; // Включает / выключает пропускание лидирующего пробела
}

// Возвращает предыдущую считанную лексему
// Если не было считано никакой лексемы - вызывает get_token
// для чтения лексемы
Lexem Parser::get_last() { // Получение предыдущей лексемы
    if (last.type == LT_Unknown) // Если тип последней лексемы неизвестен
        return get_lexem(); // Получение следующей лексемы
    return last; // Возвращение последней лексемы
}

Lexem Parser::get_lexem() // Чтение лексемы из потока
{
    char c; // Символ
    in >> c; // Считывание символа
    while (c == ' ' || c == '\t') { // Пока лексема является пробелом или табуляцией
        in >> c; // Считывание следующего символа
        if (!in) // Если конец потока
            break; // Конец цикла
    }

    if (c == '\n') { // Если лексема является переносом строки
        last.type = LT_EOL; // Тип лексемы становится "конец строки"
        ++line_number; // Переход на следующую строку
        // Отладочная печать номеров строк
        //std::cout << "[" << line_number << "]";
        return last; // Возвращение последней лексемы
    }

    if (!in) { // Конец потока
        last.type = LT_End; // Тип лексемы становится "конец файла"
        return last; // Возвращение последней лексемы
    }

    // Строка в кавычках
    if (c == '\"') { // Если лексема является символом кавычек
        last.name = ""; // Очищение имени последней лексемы
        in >> c; // Считывание следующего символа
        while (c != '\"') { // Пока символ не является символом кавычек
            last.name += c; // Добавление символа к имени лексемы
            in >> c; // Считывание следующего символа
            if (c == '\n' || !in) // Если обнаружены незакрытые кавычки
                throw "Unpaired quotation marks"; // Вывод сообщенния о том, что в строке находятся непарные кавычки
        }
        last.type = LT_String; // Тип лексемы становится "строка"
        return last; // Возвращение последней лексемы
    }

    // Разделители
    // TODO: ДОБАВИТЬ ДЛЯ НОВОЙ ФУНКЦИИ
    const std::string delimiters("^+-*/();=<>"); // Разделители
    std::string::size_type pos = delimiters.find(c); // Поиск среди разделителей считанный символ

    if (pos != std::string::npos) { // Если символ найден
        last.type = LT_Delimiter; // Тип лексемы становится "разделитель"
        last.delimiter = c; // Запись символа в поле разледителя лексеммы
        return last; // Возвращение последней лексемы
    }

    // Числовое значение
    if (isdigit(c) || c == '.') { // Если символ является числом или точкой
        in.putback(c); // Символ снова становится читаемым
        in >> last.value; // Запись символа в значение лексемы 
        last.type = LT_Number; // Тип лексемы становится "число"
        return last; // Возвращение последней лексемы
    }

    // Идентификатор
    if (isalpha(c)) { // Если символ является буквой
        last.name = ""; // Очищение имени последней лексемы
        while (isalpha(c)) { // Пока символ является буквой
            last.name += c; // Добавление символа к имени лексемы
            in >> c; // Считывание следующего символа
        }
        in.putback(c); // Символ снова становится читаемым
        last.type = LT_Identifier; // Тип лексемы становится "идентификатор"
        return last; // Возвращение последней лексемы
    }

    throw "Unexpected lexem"; // Вывод сообщенния о том, что лексема не распознана
}

Parser::Holder Parser::Hold() const // Конструктор объекта для хранения информации о позиции в потоке
{
    Holder holder; // Объект для хранения
    holder.pos = in.tellg(); // Хранение позиции в потоке
    holder.line_number = line_number; // Хранение номера строки
    return holder; // Возвращение объекта для хранения
}

void Parser::Fetch(Holder holder) // Определение позиции в буфере ввода и номер строки
{
    in.seekg(holder.pos); // Получение позиции в буфере потока
    line_number = holder.line_number; // Получение номера строки
}

void Parser::Reset() { // Очистка буфера
    in.clear(); // Очистка буфера потока
    in.seekg(0); // Позиция в буфере становится 0
}

bool Parser::SkipUntilEOL() { // Пропуск строки
    while (get_lexem().type != LT_EOL) { // Пока тип лексемы не является концом строки
        if (get_lexem().type == LT_End) // Если тип лексемы является концом файла
            return false;
    }
    get_lexem(); // Получение следующей лексемы
    return true;
}